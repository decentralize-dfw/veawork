<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>HOME</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/meshoptimizer@0.19.0/meshopt_decoder.js"></script>

    <style>
        @font-face {
            font-family: 'Telegrama Raw';
            src: url('https://raw.githubusercontent.com/decentralize-dfw/font/main/vea.ttf') format('truetype');
        }
        @font-face {
            font-family: 'Telegrama Render';
            src: url('https://raw.githubusercontent.com/decentralize-dfw/font/main/vea.ttf') format('truetype');
        }

        :root {
            /* ========== CORE COLORS ========== */
            --ui-color: #3d3d3d;
            --bg-color: #ededed;
            --accent-color: #FF006A;
            
            /* ========== FONTS ========== */
            --font-headers: 'Telegrama Raw', sans-serif;
            --font-body: 'Telegrama Render', sans-serif;
            
            /* ========== HOVER EFFECT PARAMETERS ========== */
            --hover-lift-distance: 100px;
            --hover-animation-duration: 0.3s;
            --hover-label-font-size: 62px;
            --hover-label-rotation-x: 0deg;
            --hover-label-rotation-y: 45deg;
            --hover-label-rotation-z: 0deg;
            --hover-label-offset-y: -50px;
            
            /* ========== SIDE PANEL PARAMETERS ========== */
            --panel-width: 480px;
            --panel-right-offset: 20px;
            --panel-top-offset: 80px;
            --panel-bottom-offset: 20px;
            --panel-border-radius: 24px;
            --panel-bg-opacity: 0.4;
            --panel-blur: 8px;
            --panel-animation-duration: 1s;
            
            --panel-media-padding-horizontal: 10%;
            --panel-media-padding-top: 10%;
            --panel-media-spacing: 20px;
            
            --panel-title-font-size: 2rem;
            --panel-meta-font-size: 0.9rem;
            --panel-desc-font-size: 0.95rem;
            --panel-text-spacing: 1.5rem;
            --panel-content-padding: 2rem;
            
            /* ========== ZOOM PARAMETERS ========== */
            --selection-zoom-factor: 0.5;
            --zoom-in-animation-duration: 0.8s;
            --zoom-out-animation-duration: 1.2s;
            
            /* ========== INITIAL CAMERA ========== */
            --initial-camera-zoom: 0.68;
            
            /* ========== INTERACTION PARAMETERS ========== */
            --enable-object-dragging: yes;
            --click-threshold-pixels: 7;
            
            /* ========== LIGHTING ========== */
            --ambient-light-intensity: 2.0;
            --directional-light-intensity: 2.5;
            
            /* Mobile fallback */
            --app-height: 100vh;
        }

        html, body {
            font-family: var(--font-body);
            background-color: white;
            color: var(--ui-color);
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            height: var(--app-height);
            touch-action: none;
        }

        #scene-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
            touch-action: none;
        }

        #loader {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: white;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease-out;
        }
        
        .loader-text {
            font-family: var(--font-headers);
            font-size: 2rem;
            color: var(--ui-color);
            animation: pulse 1s infinite;
        }
        
        .loader-progress {
            font-family: var(--font-body);
            font-size: 1rem;
            color: var(--ui-color);
            margin-top: 1rem;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* ========== SIDE PANEL ========== */
        #side-panel {
            position: fixed;
            right: var(--panel-right-offset);
            top: var(--panel-top-offset);
            width: var(--panel-width);
            max-height: calc(100vh - var(--panel-top-offset) - var(--panel-bottom-offset));
            background: rgba(255, 255, 255, var(--panel-bg-opacity));
            backdrop-filter: blur(var(--panel-blur));
            -webkit-backdrop-filter: blur(var(--panel-blur));
            border-radius: var(--panel-border-radius);
            border: 1px solid rgba(0, 0, 0, 0.1);
            transform: translateY(calc(100vh + 100px));
            opacity: 0;
            visibility: hidden;
            transition: transform var(--panel-animation-duration) cubic-bezier(0.4, 0, 0.2, 1),
                        opacity var(--panel-animation-duration) cubic-bezier(0.4, 0, 0.2, 1),
                        visibility var(--panel-animation-duration) cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            overflow-y: auto;
            overflow-x: hidden;
            padding-top: 1rem;
            padding-bottom: var(--panel-bottom-offset);
        }
        
        #side-panel.open {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }
        
        #side-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        #side-panel::-webkit-scrollbar-track {
            background: transparent;
            margin: var(--panel-border-radius) 0;
        }
        
        #side-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        
        #side-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
            background-clip: padding-box;
        }
        
        .panel-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }
        
        .panel-close-btn:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: rotate(90deg);
        }
        
        .panel-media-section {
            padding: calc(var(--panel-media-padding-top)) calc(var(--panel-media-padding-horizontal)) var(--panel-media-spacing);
        }
        
        .panel-media-item {
            width: 100%;
            aspect-ratio: 1;
            margin-bottom: var(--panel-media-spacing);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            background: rgba(0, 0, 0, 0.05);
        }
        
        .panel-media-item:last-child {
            margin-bottom: 0;
        }
        
        .panel-media-item img,
        .panel-media-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .media-play-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--ui-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            z-index: 5;
        }
        
        .media-play-button:hover {
            transform: translate(-50%, -50%) scale(1.1);
            background: white;
        }
        
        .media-play-button.playing {
            opacity: 0;
            pointer-events: none;
        }
        
        .panel-text-section {
            padding: var(--panel-content-padding);
            padding-top: 0;
        }
        
        .panel-title {
            font-family: var(--font-headers);
            font-size: var(--panel-title-font-size);
            line-height: 1.1;
            text-transform: uppercase;
            margin-bottom: var(--panel-text-spacing);
        }
        
        .panel-meta {
            font-family: var(--font-body);
            font-size: var(--panel-meta-font-size);
            margin-bottom: var(--panel-text-spacing);
            display: flex;
            gap: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
        }
        
        .panel-description {
            font-family: var(--font-body);
            font-size: var(--panel-desc-font-size);
            line-height: 1.6;
            white-space: pre-line;
        }

        @media (max-width: 768px) {
            #side-panel {
                right: 10px;
                width: calc(100vw - 20px);
                max-height: 60vh;
            }
        }
    </style>
    
    <script>
        const appHeight = () => {
            const doc = document.documentElement;
            doc.style.setProperty('--app-height', `${window.innerHeight}px`);
        }
        window.addEventListener('resize', appHeight);
        appHeight();
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-text">INITIALIZING...</div>
        <div class="loader-progress">0%</div>
    </div>

    <div id="scene-container"></div>

    <div id="side-panel">
        <button class="panel-close-btn" onclick="closePanel()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                <path d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z" fill="black"/>
            </svg>
        </button>
        <div class="panel-media-section" id="panel-media"></div>
        <div class="panel-text-section">
            <div class="panel-title" id="panel-title"></div>
            <div class="panel-meta">
                <span id="panel-year"></span>
                <span id="panel-cats"></span>
            </div>
            <div class="panel-description" id="panel-desc"></div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        // Read parameters from CSS variables
        const getParam = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        const getParamNum = (name) => parseFloat(getParam(name));
        
        const PARAMS = {
            hoverLiftDistance: getParamNum('--hover-lift-distance'),
            hoverAnimationDuration: parseFloat(getParam('--hover-animation-duration')) * 1000,
            hoverLabelFontSize: getParamNum('--hover-label-font-size'),
            hoverLabelRotationX: parseFloat(getParam('--hover-label-rotation-x')),
            hoverLabelRotationY: parseFloat(getParam('--hover-label-rotation-y')),
            hoverLabelRotationZ: parseFloat(getParam('--hover-label-rotation-z')),
            hoverLabelOffsetY: getParamNum('--hover-label-offset-y'),
            
            selectionZoomFactor: getParamNum('--selection-zoom-factor'),
            zoomInAnimationDuration: parseFloat(getParam('--zoom-in-animation-duration')) * 1000,
            zoomOutAnimationDuration: parseFloat(getParam('--zoom-out-animation-duration')) * 1000,
            
            initialCameraZoom: getParamNum('--initial-camera-zoom'),
            
            panelAnimationDuration: parseFloat(getParam('--panel-animation-duration')) * 1000,
            
            enableObjectDragging: getParam('--enable-object-dragging') === 'yes',
            clickThreshold: getParamNum('--click-threshold-pixels'),
            
            ambientLightIntensity: getParamNum('--ambient-light-intensity'),
            directionalLightIntensity: getParamNum('--directional-light-intensity')
        };

        let loadedAssets = 0;
        let totalAssets = 0;
        
        function updateLoadingProgress() {
            const progress = totalAssets > 0 ? Math.round((loadedAssets / totalAssets) * 100) : 0;
            const progressEl = document.querySelector('.loader-progress');
            if (progressEl) {
                progressEl.textContent = progress + '%';
            }
            
            if (loadedAssets >= totalAssets && totalAssets > 0) {
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => {
                        document.getElementById('loader').style.display = 'none';
                    }, 500);
                }, 300);
            }
        }

       const sceneObjects = [
  {

    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/vea3d-opt-v1.glb',
    width: 700,
    position: { x: -1000, y: 1300, z: -700 },
    rotation: { x: 0, y: 45, z: 0 },
    scale: 300,
    modalContent: {
      name: "VEA IN A BREATH",
      categories: { sub1: "2025", sub2: "ABOUT" },
      description: "VEA combine architecture, art direction, and digital storytelling to create a multidimensional universe for each individual story.\n\n\nMinimal, sculptural, futuristic aesthetic\nArchitectural thinking applied to digital worlds\n\nCustom-made digital atmospheres (no templates)\n\nCohesive language across space, object, motion and identity\n\nA sensorial, immersive feeling in everything we produce\n\n**NOT**traditional design studio.",
      
      media: [
        { 
          type: "image", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/logovea.png",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'image',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/decentralize/main/backg.jpg',
    width: 3000,
    position: { x: -1700, y: 0, z: -1500 },
    rotation: { x: 0, y: 45, z: 0 },
    scale: 1000,
    clickable: false,
    modalContent: {
      name: "Atmosphere",
      categories: { sub1: "2024", sub2: "Environment" },
      description: "Void environment.",
      media: [
        { 
          type: "image", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/decentralize/main/backg.jpg",
          linkUrl: "https://raw.githubusercontent.com/decentralize-dfw/decentralize/main/backg.jpg",
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/daspiecesbook-opt-v11.glb',
    position: { x: -1500, y: 600, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "DAS PIECES Book",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 01",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_0dac59951f9c42efbf6b8a3a77951e00/1080p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DQo4sq2iEaH/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/daspiecesbook-opt-v11.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/93book-opt-v10.glb',
    position: { x: -500, y: 600, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "93book-opt-v10.glb",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 02",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_b443e8c0ed384e30bf532179d14769a8/1080p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DSSBQPrjFkP/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/93book-opt-v10.glb",
          linkUrl: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/93book-opt-v10.glb",
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/booth-opt-v9.glb',
    position: { x: 500, y: 600, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "booth-opt-v9.glb",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 03",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_6230b7e092674b0d8f32b87103b3c920/720p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DP3gbgpiKbS/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/booth-opt-v9.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/cicex1-opt-v8.glb',
    position: { x: 1500, y: 600, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "cicex1-opt-v8.glb",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 04",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_fba3080416b3426783eefde37e081efa/720p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DQHQ-3MCBkP/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/cicex1-opt-v8.glb",
          linkUrl: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/cicex1-opt-v8.glb",
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    //type: 'image',
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/ipod-opt-v2.glb',
    width: 500,
    position: { x: -1500, y: 200, z: 100 },
    rotation: { x: 0, y: 90, z: 0 },
    scale: 300,
    modalContent: {
      name: "Acoustic Architecture System",
      categories: { sub1: "2025", sub2: "HTML", sub3: "kimse." },
      description: "Spectral Point Cloud Interpretation\n\nEach sound particle is positioned in 3D space according to its properties, mapping complex spectral data to a tangible, volumetric architecture.\n\n\n1. SPATIAL AXES (X, Y, Z)\n\nX-AXIS (Continuous Frequency): Defines the 'tonal space' from low notes (left/bass) to high notes (right/treble). This axis maintains a continuous log-frequency mapping, allowing for three-dimensional spatial distribution.\nY-AXIS (Amplitude): Defines the 'power' or 'volume' of the sound. Higher amplitude (loud) sounds move vertically up the Y-axis.\nZ-AXIS (Timbre/Harmonics): Defines the 'timbral richness.' Pure sounds (low Z) are near the front, while harmonically rich sounds (vocals, distortion, chords) are placed deeper along the Z-axis.\n\n\n2. VISUAL PROPERTIES\n\nCOLOR (Spectral Band Identity): Represents the sound's primary spectral range, allowing the viewer to instantly distinguish between core frequency categories regardless of the note's exact pitch:\nBASS (Red/Magenta):** < 250 Hz (Kicks, Sub-Bass)\nMID (Yellow/Orange):** 250 Hz - 1 kHz (Low instruments, Body)\nVOCAL (Green):** 1 kHz - 4 kHz (Vocals, Clarity, Leads)\nTREMBLE (Blue/Cyan):** > 4 kHz (Hi-Hats, Air, Sibilance)\nSCALE (Size): Reflects the instantaneous volume (Amplitude). Louder sounds create larger particles.\nBRIGHTNESS (Bloom): The sound's energy generates a glow effect, controlled via the 'Bloom' settings in the control panel.",
      media: [
        { 
          type: "html", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/finder/refs/heads/main/birdsv10.html",
          linkUrl: "https://www.virtuallyeverafter.work/sv",
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/daspieces1-opt-v6.glb',
    position: { x: -500, y: 0, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "daspieces1-opt-v6.glb",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 06",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_ac3a4bd792a04e6ab5a9009dde170ea8/1080p/mp4/file.mp4",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/daspieces1-opt-v6.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/sandalye-opt-v5.glb',
    position: { x: 500, y: 0, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "the waiting room no.1",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 07",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_a98194f1174b434ea9f7f1ce355d6c81/1080p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DQmUnZkCHOl/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/sandalye-opt-v5.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/facade-opt-v4.glb',
    position: { x: 1500, y: 0, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "facade-opt-v4.glb",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 08",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_cbec7d394bfd417193d86ba249c93d63/720p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DP6cIwoCOFO/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/facade-opt-v4.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/telefon-opt-v3.glb',
    position: { x: -1500, y: -600, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "telefon-opt-v3.glb",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 09",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_0347ca404afa45c7b59394ddad5370d0/720p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DP03diJiMCw/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/telefon-opt-v3.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/wireframe-opt-v2.glb',
    position: { x: -500, y: -600, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "wireframe-opt-v2.glb",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 10",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_9bb1f95695fd4d83aa68eda3da571e47/1080p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DQUK0uOiORM/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/wireframe-opt-v2.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/mektup-opt-v1.glb',
    position: { x: 500, y: -600, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "unsend letter",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 11",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_f47ac95a2e74487993200753805e8cee/1080p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DQ6mGDAiELU/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/mektup-opt-v1.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/co-chair-opt-v1.glb',
    position: { x: 1500, y: -600, z: 100 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: 500,
    modalContent: {
      name: "daspiecesbook-copy.glb",
      categories: { sub1: "2025-2026", sub2: "Brand Construction", sub3: "Vea" },
      description: "soon to be announced",
      media: [
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/co-chair-opt-v1.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/cicex2-opt-v7.glb',
    position: { x: -1500, y: -1200, z: 100 },
    rotation: { x: 0, y: 15, z: 0 },
    scale: 500,
    modalContent: {
      name: "virtually Grown",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 05",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_1c655cbc2e58493ea6dd0f8ab6fc46e1/720p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DQEj6rJCMbS/",
          linkText: "Open REEL on Instagram"
        },
        { 
          type: "model", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/cicex2-opt-v7.glb",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/mail.glb',
    position: { x: -500, y: -1000, z: 100 },
    rotation: { x: 0, y: 80, z: 0 },
    scale: 2500,
    modalContent: {
      name: "booth-copy.glb",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Item 14 (Copy)",
      media: [
        { 
          type: "video", 
          src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4",
          linkUrl: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4",
          linkText: "OPEN IN A NEW TAB"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/serfvs-v3.glb',
    position: { x: 500, y: -1000, z: 100 },
    rotation: { x: 0, y: 45, z: 0 },
    scale: 150,
    modalContent: {
      name: "cicex1-copy.glb",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "1) Worldbuilding\n\nDesigning the digital 'space' a brand lives in. \nWeb based 3D interactive experiences \nAtmospheric spatial interfaces \nCustom-designed architectural objects \n\n\n 2) Identity Building \n\nBuilding a brand's identity specifically for the digital realm. \nLogo design \nColor & typography systems \nWebsite  \n\n\n3) Digital Content \n\nTurning the world into visuals, motion and narrative. \nCinematic reels & videos \nVisual storytelling \nSocial media content in one consistent aesthetic",
      media: [
        { 
          type: "video", 
          src: "https://video.wixstatic.com/video/bbd25a_9c4fa7997a654eb2b1fa56ac22155d27/1080p/mp4/file.mp4",
          linkUrl: "https://www.instagram.com/virtually.ever.after/reel/DSXgFb8iNB-/",
          linkText: "Open REEL on Instagram"
        }
      ]
    }
  },
  {
    type: 'model',
    src: 'https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/vea-iwwd-opt-v2.glb',
    position: { x: 1500, y: -1000, z: 100 },
    rotation: { x: 0, y: 45, z: 0 },
    scale: 150,
    modalContent: {
      name: "WHAT WE DO",
      categories: { sub1: "2024", sub2: "Archive", sub3: "Vea" },
      description: "Virtually ever after is a digital architecture and aesthetic worldbuilding studio.\n\nWe merge space, objects, and storytelling to create minimal, sculptural, immersive digital realms for brands, designers, and cultural projects.\n\nTo explore how architecture transforms when it becomes digital.\n\nVEA craft environments where imagination, materiality, and motion converge into a new form of experience. \n\nImagination - Space - Sound - Emotion \n\nEvery project becomes its own world.\n\n",
      media: [
        { 
          type: "html", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/veawork/refs/heads/main/spherework.html",
          linkUrl: null,
          linkText: "OPEN IN A NEW TAB"
        },
        { 
          type: "html", 
          src: "https://raw.githubusercontent.com/decentralize-dfw/veawork/main/services.html",
          linkUrl: "https://raw.githubusercontent.com/decentralize-dfw/vea-files/main/cicex2-opt-v7.glb",
          linkText: "OPEN IN A NEW TAB",
          
        }
      ]
    }
  }
];

        let camera, scene, rendererGL, controls, dragControls;
        let raycaster, mouse;
        const clickableObjects = [];
        let globalEnvMap = null;
        
        let clickStartX = 0, clickStartY = 0;
        let currentHoveredObject = null;
        let hoverLabel = null;
        let currentSelectedObject = null;
        let originalCameraState = null;
        let currentActiveVideos = [];
        
        let modalRenderer, modalScene, modalCamera, modalControls, modalAnimationFrameId, modalClock;

        init();
        animate();

        function init() {
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            const container = document.getElementById('scene-container');
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 50000);
            scene = new THREE.Scene();

            rendererGL = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            rendererGL.setPixelRatio(window.devicePixelRatio);
            rendererGL.setSize(window.innerWidth, window.innerHeight);
            rendererGL.toneMapping = THREE.ACESFilmicToneMapping;
            rendererGL.toneMappingExposure = 1.0;
            rendererGL.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(rendererGL.domElement);

            controls = new OrbitControls(camera, rendererGL.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            if (PARAMS.enableObjectDragging) {
                dragControls = new DragControls(clickableObjects, camera, rendererGL.domElement);
                dragControls.addEventListener('dragstart', () => controls.enabled = false);
                dragControls.addEventListener('dragend', () => controls.enabled = true);
            }

            const ambientLight = new THREE.AmbientLight(0xffffff, PARAMS.ambientLightIntensity);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, PARAMS.directionalLightIntensity);
            dirLight.position.set(1000, 1000, 1000);
            scene.add(dirLight);

            const pmremGenerator = new THREE.PMREMGenerator(rendererGL);
            new RGBELoader().load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr', (texture) => {
                const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                scene.environment = envMap;
                globalEnvMap = envMap;
                texture.dispose();
                pmremGenerator.dispose();
            });

            buildScene();
            
            window.addEventListener('resize', onWindowResize);
            rendererGL.domElement.addEventListener('mousedown', onPointerDown);
            rendererGL.domElement.addEventListener('mouseup', onPointerUp);
            rendererGL.domElement.addEventListener('mousemove', onMouseMove);
            rendererGL.domElement.addEventListener('touchstart', onPointerDown, { passive: false });
            rendererGL.domElement.addEventListener('touchend', onPointerUp, { passive: false });

            // Count total assets
            sceneObjects.forEach(item => {
                if (item.clickable !== false) totalAssets++;
            });
            updateLoadingProgress();
        }

        function fixGithubUrl(url) {
            if (!url) return '';
            if (url.includes('raw.githubusercontent.com') && (url.endsWith('.glb') || url.endsWith('.gltf'))) {
                return url.replace('raw.githubusercontent.com', 'raw.githack.com');
            }
            if (url.includes('github.com') && url.includes('/blob/')) {
                if (url.endsWith('.glb') || url.endsWith('.gltf')) {
                    return url.replace('github.com', 'raw.githack.com').replace('/blob/', '/');
                }
                return url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            }
            return url;
        }

        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        function createTextTexture(text, fontSize, font, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.2;
            
            ctx.font = `${fontSize}px "${font}"`;
            let maxWidth = 0;
            lines.forEach(line => {
                const w = ctx.measureText(line).width;
                if(w > maxWidth) maxWidth = w;
            });
            
            canvas.width = Math.ceil(maxWidth + 40);
            canvas.height = Math.ceil(lines.length * lineHeight + 40);
            
            ctx.font = `${fontSize}px "${font}"`;
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const centerX = canvas.width / 2;
            let startY = (canvas.height - (lines.length - 1) * lineHeight) / 2;
            
            lines.forEach((line, i) => {
                ctx.fillText(line, centerX, startY + (i * lineHeight));
            });
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return { texture: tex, width: canvas.width, height: canvas.height };
        }

        function buildScene() {
            const gltfLoader = new GLTFLoader();
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            gltfLoader.setDRACOLoader(dracoLoader);
            gltfLoader.setMeshoptDecoder(MeshoptDecoder);
            const textureLoader = new THREE.TextureLoader();

            sceneObjects.forEach(item => {
                const applyTransform = (obj3d) => {
                    if (item.position) obj3d.position.set(item.position.x, item.position.y, item.position.z);
                    if (item.rotation) obj3d.rotation.set(degToRad(item.rotation.x), degToRad(item.rotation.y), degToRad(item.rotation.z));
                    if (item.scale) {
                        if (typeof item.scale === 'number') obj3d.scale.setScalar(item.scale);
                        else obj3d.scale.set(item.scale.x, item.scale.y, item.scale.z);
                    }
                };

                const safeSrc = item.src ? fixGithubUrl(item.src) : '';

                if (item.type === 'image') {
                    const texture = textureLoader.load(safeSrc);
                    texture.colorSpace = THREE.SRGBColorSpace;
                    
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    const material = new THREE.MeshBasicMaterial({ 
                        map: texture, 
                        side: THREE.DoubleSide, 
                        transparent: true,
                        alphaTest: 0.5 
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    applyTransform(mesh);
                    
                    if (item.width) {
                        mesh.scale.set(item.width, item.width, 1);
                        texture.onload = () => {
                            const aspect = texture.image.width / texture.image.height;
                            mesh.scale.set(item.width, item.width / aspect, 1);
                        }
                    }

                    mesh.userData = { 
                        modalContent: item.modalContent,
                        clickable: item.clickable !== false,
                        originalPosition: mesh.position.clone()
                    };
                    
                    scene.add(mesh);
                    if (item.clickable !== false) clickableObjects.push(mesh);
                }

                else if (item.type === 'model') {
                    gltfLoader.load(safeSrc, (gltf) => {
                        const model = gltf.scene;
                        applyTransform(model);
                        model.userData = { 
                            modalContent: item.modalContent,
                            clickable: item.clickable !== false,
                            originalPosition: model.position.clone()
                        };
                        
                        model.traverse((child) => {
                            if (child.isMesh) child.userData = { parentRoot: model };
                        });

                        scene.add(model);
                        if (item.clickable !== false) clickableObjects.push(model);

                        loadedAssets++;
                        updateLoadingProgress();
                        fitCameraToScene();
                    });
                }
            });
        }

        function onPointerDown(e) {
            clickStartX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            clickStartY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
        }

        function onPointerUp(e) {
            const endX = e.clientX || (e.changedTouches ? e.changedTouches[0].clientX : 0);
            const endY = e.clientY || (e.changedTouches ? e.changedTouches[0].clientY : 0);

            const diffX = Math.abs(endX - clickStartX);
            const diffY = Math.abs(endY - clickStartY);

            if (diffX < PARAMS.clickThreshold && diffY < PARAMS.clickThreshold) {
                handleClick(endX, endY);
            }
        }

        function onMouseMove(e) {
            if (document.getElementById('side-panel').classList.contains('open')) return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects, true);

            if (intersects.length > 0) {
                let object = intersects[0].object;
                
                while(object.parent && !object.userData.modalContent) {
                    object = object.parent;
                    if (!object) break;
                }
                if (!object || !object.userData.modalContent) return;

                if (currentHoveredObject !== object) {
                    clearHover();
                    applyHover(object);
                }
            } else {
                clearHover();
            }
        }

        function applyHover(object) {
            if (!object.userData.originalPosition) {
                object.userData.originalPosition = object.position.clone();
            }

            currentHoveredObject = object;
            
            // Lift animation
            const targetY = object.userData.originalPosition.y + PARAMS.hoverLiftDistance;
            animatePosition(object, targetY, PARAMS.hoverAnimationDuration);

            // Create label
            if (object.userData.modalContent && object.userData.modalContent.name) {
                const { texture, width, height } = createTextTexture(
                    object.userData.modalContent.name,
                    PARAMS.hoverLabelFontSize,
                    getParam('--font-headers'),
                    getParam('--ui-color')
                );

                const labelGeo = new THREE.PlaneGeometry(width, height);
                const labelMat = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true, 
                    side: THREE.DoubleSide 
                });
                hoverLabel = new THREE.Mesh(labelGeo, labelMat);
                
                hoverLabel.position.copy(object.position);
                hoverLabel.position.y += PARAMS.hoverLabelOffsetY;
                
                hoverLabel.rotation.set(
                    degToRad(PARAMS.hoverLabelRotationX),
                    degToRad(PARAMS.hoverLabelRotationY),
                    degToRad(PARAMS.hoverLabelRotationZ)
                );

                scene.add(hoverLabel);
            }
        }

        function clearHover() {
            if (currentHoveredObject) {
                animatePosition(
                    currentHoveredObject, 
                    currentHoveredObject.userData.originalPosition.y, 
                    PARAMS.hoverAnimationDuration
                );
                currentHoveredObject = null;
            }

            if (hoverLabel) {
                scene.remove(hoverLabel);
                hoverLabel.geometry.dispose();
                hoverLabel.material.dispose();
                hoverLabel = null;
            }
        }

        function animatePosition(object, targetY, duration) {
            const startY = object.position.y;
            const startTime = Date.now();

            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = easeOutCubic(progress);

                object.position.y = startY + (targetY - startY) * eased;

                if (hoverLabel && object === currentHoveredObject) {
                    hoverLabel.position.y = object.position.y + PARAMS.hoverLabelOffsetY;
                }

                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            update();
        }

        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        function handleClick(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects, true);

            if (intersects.length > 0) {
                let object = intersects[0].object;
                
                while(object.parent && !object.userData.modalContent) {
                    object = object.parent;
                    if (!object) break;
                }

                if (object && object.userData.clickable !== false && object.userData.modalContent) {
                    openPanel(object.userData.modalContent, object);
                }
            }
        }

        function openPanel(content, object) {
            // Stop all active videos
            currentActiveVideos.forEach(v => {
                v.pause();
                v.currentTime = 0;
            });
            currentActiveVideos = [];

            // Store camera state
            if (!originalCameraState) {
                originalCameraState = {
                    position: camera.position.clone(),
                    left: camera.left,
                    right: camera.right,
                    top: camera.top,
                    bottom: camera.bottom,
                    target: controls.target.clone()
                };
            }

            currentSelectedObject = object;

            // Apply zoom with animation
            if (object) {
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                
                const zoomFactor = PARAMS.selectionZoomFactor;
                
                animateCameraZoom({
                    left: camera.left * zoomFactor,
                    right: camera.right * zoomFactor,
                    top: camera.top * zoomFactor,
                    bottom: camera.bottom * zoomFactor,
                    target: center
                }, PARAMS.zoomInAnimationDuration);
            }

            // Populate panel
            document.getElementById('panel-title').textContent = content.name || 'Untitled';
            
            const cats = content.categories || {};
            const year = cats.sub1 || '';
            const otherCats = Object.values(cats).filter(v => v !== year && v !== '-').join(', ');
            
            document.getElementById('panel-year').textContent = year;
            document.getElementById('panel-cats').textContent = otherCats;
            document.getElementById('panel-desc').textContent = content.description || '';

            // Render media
            const mediaContainer = document.getElementById('panel-media');
            mediaContainer.innerHTML = '';

            if (content.media && content.media.length > 0) {
                content.media.forEach(m => {
                    const fixedSrc = fixGithubUrl(m.src);
                    const mediaItem = document.createElement('div');
                    mediaItem.className = 'panel-media-item';

                    if (m.type === 'image') {
                        const img = document.createElement('img');
                        img.src = fixedSrc;
                        mediaItem.appendChild(img);
                    } 
                    else if (m.type === 'video') {
                        const video = document.createElement('video');
                        video.src = fixedSrc;
                        video.playsInline = true;
                        video.muted = false;
                        video.style.width = '100%';
                        video.style.height = '100%';
                        video.style.objectFit = 'cover';

                        const playBtn = document.createElement('div');
                        playBtn.className = 'media-play-button';
                        playBtn.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                            <path d="M8 5v14l11-7z" fill="#3d3d3d"/>
                        </svg>`;

                        playBtn.onclick = () => {
                            video.play();
                            playBtn.classList.add('playing');
                            currentActiveVideos.push(video);
                            
                            video.onended = () => {
                                playBtn.classList.remove('playing');
                                currentActiveVideos = currentActiveVideos.filter(v => v !== video);
                            };
                        };

                        mediaItem.appendChild(video);
                        mediaItem.appendChild(playBtn);
                    }
                    else if (m.type === 'model') {
                        const container = document.createElement('div');
                        container.className = 'w-full h-full relative';
                        container.style.background = '#f4f4f4';
                        
                        mediaItem.appendChild(container);
                        initModal3D(container, fixedSrc);
                    }
                    else if (m.type === 'html') {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'w-full h-full bg-white relative overflow-hidden';
                        
                        let url = fixedSrc;
                        if (url.includes('raw.githubusercontent.com') && url.endsWith('.html')) {
                            url = url.replace('raw.githubusercontent.com', 'raw.githack.com').replace('/refs/heads/', '/');
                        }

                        const iframe = document.createElement('iframe');
                        iframe.src = url;
                        iframe.className = 'absolute top-0 left-0 w-[200%] h-[200%] border-none origin-top-left scale-50';
                        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
                        iframe.allowFullscreen = true;
                        
                        wrapper.appendChild(iframe);
                        mediaItem.appendChild(wrapper);
                    }

                    mediaContainer.appendChild(mediaItem);
                });
            }

            document.getElementById('side-panel').classList.add('open');
        }

        function initModal3D(container, src) {
            modalScene = new THREE.Scene();
            modalScene.background = new THREE.Color(0xf4f4f4);
            modalClock = new THREE.Clock();

            if (globalEnvMap) {
                modalScene.environment = globalEnvMap;
            }

            const width = container.clientWidth || 300;
            const height = container.clientHeight || 300;
            modalCamera = new THREE.PerspectiveCamera(45, width / height, 0.001, 100000);
            
            modalRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            modalRenderer.setSize(width, height);
            modalRenderer.setPixelRatio(window.devicePixelRatio);
            modalRenderer.outputColorSpace = THREE.SRGBColorSpace;
            modalRenderer.toneMapping = THREE.ACESFilmicToneMapping;
            modalRenderer.toneMappingExposure = 1.0;
            container.appendChild(modalRenderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 3.0);
            modalScene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(1000, 1000, 1000);
            modalScene.add(dirLight);
            
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 3.0);
            hemiLight.position.set(0, 20, 0);
            modalScene.add(hemiLight);

            modalControls = new OrbitControls(modalCamera, modalRenderer.domElement);
            modalControls.enableDamping = true;
            modalControls.autoRotate = true;
            modalControls.autoRotateSpeed = 2.0;
            
            modalControls.addEventListener('start', function() {
                modalControls.autoRotate = false;
            });

            const gltfLoader = new GLTFLoader();
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            gltfLoader.setDRACOLoader(dracoLoader);
            gltfLoader.setMeshoptDecoder(MeshoptDecoder);

            gltfLoader.load(src, (gltf) => {
                const model = gltf.scene;
                
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                modalControls.target.copy(center);
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = modalCamera.fov * (Math.PI / 180);
                
                let cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2)));
                if (cameraZ < 0.01) cameraZ = 10;
                
                cameraZ *= 2.0;
                
                modalCamera.position.set(center.x, center.y + (size.y * 0.2), center.z + cameraZ);
                
                modalControls.maxDistance = cameraZ * 10;
                modalControls.update();

                modalScene.add(model);
                
                if (gltf.animations && gltf.animations.length > 0) {
                    const mixer = new THREE.AnimationMixer(model);
                    gltf.animations.forEach(clip => mixer.clipAction(clip).play());
                    modalScene.userData.mixer = mixer;
                }
            });

            modalClock.start();
            const animateModal = () => {
                modalAnimationFrameId = requestAnimationFrame(animateModal);
                
                if (modalRenderer && container) {
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    const canvas = modalRenderer.domElement;
                    if (canvas.width !== w || canvas.height !== h) {
                        modalRenderer.setSize(w, h, false);
                        modalCamera.aspect = w / h;
                        modalCamera.updateProjectionMatrix();
                    }
                }
                
                const delta = modalClock.getDelta();

                if (modalControls) modalControls.update();
                if (modalScene && modalScene.userData.mixer) modalScene.userData.mixer.update(delta);
                if (modalRenderer && modalScene && modalCamera) modalRenderer.render(modalScene, modalCamera);
            };
            animateModal();
        }

        function animateCameraZoom(targetState, duration) {
            const startState = {
                left: camera.left,
                right: camera.right,
                top: camera.top,
                bottom: camera.bottom,
                target: controls.target.clone()
            };
            
            const startTime = Date.now();
            
            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = easeOutCubic(progress);
                
                camera.left = startState.left + (targetState.left - startState.left) * eased;
                camera.right = startState.right + (targetState.right - startState.right) * eased;
                camera.top = startState.top + (targetState.top - startState.top) * eased;
                camera.bottom = startState.bottom + (targetState.bottom - startState.bottom) * eased;
                
                if (targetState.target) {
                    controls.target.lerpVectors(startState.target, targetState.target, eased);
                }
                
                camera.updateProjectionMatrix();
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            update();
        }

        window.closePanel = function() {
            // Stop videos
            currentActiveVideos.forEach(v => {
                v.pause();
                v.currentTime = 0;
            });
            currentActiveVideos = [];
            
            // Cleanup modal 3D
            if (modalAnimationFrameId) {
                cancelAnimationFrame(modalAnimationFrameId);
                modalAnimationFrameId = null;
            }
            if (modalRenderer) {
                modalRenderer.dispose();
                modalRenderer = null;
            }
            if (modalScene) modalScene = null;

            // Restore camera with animation
            if (originalCameraState) {
                animateCameraZoom({
                    left: originalCameraState.left,
                    right: originalCameraState.right,
                    top: originalCameraState.top,
                    bottom: originalCameraState.bottom,
                    target: originalCameraState.target
                }, PARAMS.zoomOutAnimationDuration);
                
                originalCameraState = null;
            }

            currentSelectedObject = null;
            document.getElementById('side-panel').classList.remove('open');
        }

        function fitCameraToScene() {
            if (!scene || !camera || clickableObjects.length === 0) return;

            const boundingBox = new THREE.Box3();
            clickableObjects.forEach(obj => boundingBox.expandByObject(obj));

            const center = new THREE.Vector3();
            boundingBox.getCenter(center);
            
            const sphere = new THREE.Sphere();
            boundingBox.getBoundingSphere(sphere);
            const radius = sphere.radius;

            const aspect = window.innerWidth / window.innerHeight;
            const padding = PARAMS.initialCameraZoom;
            const xOffset = -750;
            const yOffset = -75;
            const dist = 15000;

            if (aspect > 1) {
                camera.top = radius * padding;
                camera.bottom = -radius * padding;
                camera.left = -radius * aspect * padding;
                camera.right = radius * aspect * padding;
            } else {
                camera.left = -radius * padding;
                camera.right = radius * padding;
                camera.top = radius / aspect * padding;
                camera.bottom = -radius / aspect * padding;
            }

            camera.position.set(center.x + dist + xOffset, center.y + yOffset, center.z + dist);
            const targetPoint = new THREE.Vector3(center.x + xOffset, center.y + yOffset, center.z);
            camera.lookAt(targetPoint);

            if (controls) {
                controls.target.copy(targetPoint);
                controls.update();
            }
            camera.updateProjectionMatrix();
        }

        function onWindowResize() {
            rendererGL.setSize(window.innerWidth, window.innerHeight);
            fitCameraToScene();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            rendererGL.render(scene, camera);
        }
    </script>
</body>
</html>
